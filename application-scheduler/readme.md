Данный проект представляет собой реализацию механизма отложенных событий.
Принцип работы:

   1. Каждое приходящее событие кладётся в `DelayQueue` и содержит ссылку на задачу, дату и время выполнения события, а также порядок, в котором оно пришло в очередь
   2. Если очередь заполнена, события поступают на обработку пулу потоков немедленно
   3. Во время занесение в очередь производится сортировка по дате, времени и порядку выполнения события 
   4. На момент наступления даты и времени выполнения события, оно вынимается из очереди и поступает в обработку пула потоков. 
   В качестве пула был выбран ForkJoinPool по причине встроенного механизма контроля выполнения связанных задач. 
   Поток, осуществляющий проверку даты и времени выполнения события также находится в этом пуле.
   5. После взятия события из очереди производится проверка следующего за ним события, то есть текущего головного элемента очереди. 
   Проверка сравнивает даты и время выполнения этого и текущего событий, если они окажутся равными, то пулу потоков будет дано указание выполнить следующее событие только после завершения работы текущего. Это необходимо для контроля порядка выполнения одновременных событий
   6. В случае необходимости механизм выполнения событий можно остановить. 
   В процессе остановки будут отменены все запущенные события 
      
 Данное решение конфигурируемое. В качестве параметров конфигурации можно задать:
  * Количество потоков пула
  * Обработчик ошибок выполнения отложенных событей
  * Обработчик ошибок работы пула
  * Флаг ожидания отмены всех событий при выключении обработчика
  * Таймаут ожидания отмены всех событий при выключении обработчика
  * Максимальный размер очереди событий
  
 В проекте имеются тесты.
 
 Касательно комментария `DeferredEventObserver:63` - изначально в качестве сигнала выхода из цикла использовался `volatile` флаг, выставляемый на `true` , однако вариант с прерыванием мне показался более быстрым и допустимым, так как поток, в рамках которого выполняется функция `observeQueue()`, контроллируется приватным пулом и не может быть прерван вне класса `DeferredEventObserver`, кроме как через `shutdown()`
 
 Касательно констант `DeferredExecutorConstants` - `MAX_VALUE - 8` взял из `PriorityBlockingQueue`, опираясь на `javadoc` комментарий над этим полем в очереди (собственный анализ оптимального значения не проводил)
 
 В рамках расширения хотел бы сделать:
   * Более гибкое конфигурирование обработчика
   * Провести более глубокий анализ `ForkJoinPool` на выявление недочётов..опираясь на опыт с `ThreadPoolExecutor`
   * Опробировать систему и, возможно, на её основе реализовать серверный шедулер с применением возможности контроля порядка выполнения одновременных событий
   
Опасения: Некоторые тесты (как правило те, которые в 2 потока работают) могут давать отрицательные результаты из-за погрешности в наносекунды (при сравнении реального и ожидаемого времени выполнения события)...ну и иной потоковой магии :) 
   
 
