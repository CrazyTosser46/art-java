# ADK Модуль "application-service"

## Назначение модуля
Даннй модуль представляет собой набор архитектурной классов для реализации сервисной модели АДК.

Дополнительно, сервис включает в себя библиотеку resilience4j, позволяющей использовать следующий функционал:

1. Автоматический выключатель
2. Автоматическая переотправка
3. Ограничение количества запросов
 
Ключевые компоненты:

1. `ServiceController`
2. `ServiceSpecification`
3. `ServiceModule`
4. `ServiceExecutionInterceptor`
5. `ServiceExecutor`

Сервисная модель АДК заключается в следующем.

Сервис представляет функциональную единицу, выполняющуюу набор конкретных задач.
Предположим, `CrmBalanceService` - сервис по рабоет с балансом, который содержит методы, вроде `getBalance()`, `calculateBalance()` и так далее.

Сервис может быть Java интерфейсом со `static` методами. На мой взгляд, данный вид сервиса наиболее экономичный и оптимальный.

У каждого сервиса должна быть спецификация. Спецификации могут быть разных типов. Она выполняется две основные задачи:

1. Хранение информации о сервисе
2. Вызов метода сервиса по идентификатору

Все спецификации хранятся в реестре. Реестр сервисов - это пара `serviceId:serviceSpecification`

Для вызова сервиса используется `ServiceController`.
Пример: `ServiceController.<BalanceRequest, BalanceResponse>executeServiceMethod(CRM_BALANCE_SERVICE, GET_BALANCE, balanceRequest)`
* CRM_BALANCE_SERVICE - идентификатор сервиса
* GET_BALANCE - идентификатор метода
* balanceRequest - запрос

Вызов сервиса проходит через следующие шаги:
1. По `serviceId` вытащить из реестра спецификацию сервиса
2. Взять из спецификации `DeactivationConfig` и проверить на предмет деактивации сервиса.
Если сервис деактивирован - вызов не произойдет.
3. Взять из спецификации интерцепторы. По умолчанию будут выданы интерцепторы из конфигурации модуля. Вызвать каждый интерцептор. Среди интерцепторв могут быть: 
 `ServiceLoggingInterception` - выполняет логирование запросов и ответов сервиса 
 и `ServiceValidationInterception` - выполняет валидацию запросов сервиса
 4. Далее будет вызвана последовательность `ExceptionWrapper`-ов. Каждый `wrapper` оборачивает в себя вызов либо последующего враппера, либо `ServiceExecutor`. Предназначение врапперов заключается в поглощении и обработки exception-ов, которые могут быть выброшены в процессе выполнения сервиса. Враппер получает exception, и возвращает ServiceResponse с соответствующим `errorMessage`.
 5. Далее `ServiceExecutor` последовательно вызывается три функциональных компонента из `resilience4j`
 6. Вызов спецификации `executeMethod(methodId, request)`
 7. Switch по идентификатору метода
 8. Вызов сервиса
 9. Обратный процесс "прогона" интерцепторов
 10. Возвращение ответа из `ServiceController`

## Подробнее про resilience4j

* Автоматический выключатель (CircuitBreaker):
Данный компонент отвечает за предотвращение ситуации с `ThreadStuck`. Данная ситуация возникает в силу ожидания большого количества потоков выполнения какой-либо операции. Чаще всего ситуация возникает при взаимодействии с недаекватно работающей внешней системой, которая не отвечает и взаимодействие падает с timeout exception. CircuitBreaker позволит при возникновении данной ситуации предотвратить дальнейший вызов сервиса в принципе. То есть, в том случае, когда мы получили несколько успешных запросов, мы "переводим" выключатель в состояние "OPEN", и обрубаем все приходящие в наш сервис запросы до их обработки. После определенного количества успешных вызовов, мы возвращаем выключатель в состояние "HalfOpen" и начинаем выполнять запросы. В случае повтороного возникновения ошибки операция повторяется
* Автоматические переотправки (Retry):
Данный компонент выполнит повторный вызов сервиса при возникновении `exception` - а
* Ограничение количества запросов (RateLimiter):
Данный компонент выполняет подсчётов запросов за единицу времени. В случае, если количество запросов превышает допустимое, то компнент не допустит вызов сервиса

## Основная функция модуля:
Архитектурная сервисная модель AKD 


## Что почитать
[resilience4j](https://github.com/resilience4j/resilience4j)
